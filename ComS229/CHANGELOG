24 April - updated attack behavior

*monsters don't attack one another now - move aside as needed
* added attack function
	* calculated and updated hit point values
	* game now correctly hadles attacks
* implemented updating of speed - maybe problems with negative speeds?
	* try to keep actual_speed and speed
	* speed is set to 1 whenever actual_speed would go negative
	* is set approparately whenactual_speed goes above 0

20 April - fixed bug - can now swap items

* misread documentation

19 April - implemented object equip.unequiop/drop/delete

* through testing and implementation of object behavior
	* had to go back and make sure that I had copies of everything.
* As of now, items are smart - can't equip more that one type, expect rings

18 April - implemented object stacks

* had to redo how I was storing objects on dungeon
	* now stored as stacks
* implemented linked list for standby_ and equiped_lists
* implemented prompt window to list standby and equiped items

14 April - update README and bug

* found & fixed annoying bug, invalid placement of objects occasionly
* Implemented top color for stacked objects

12 April - finish generate monster and objects

* finished method to randomly generate required number of player_t
  * implemented method to randomly generate required number of objects
* modified generate_dungeon to randomly place objects
* added new field to tile_struct, can now hold an array of objects
* added methods to place and retrieve objects from tile in dungeon
  * if more than one object, printed as '&'

11 April - add color_pair generation, update player_t

* When monster and object template files are parsed, color pairs are created as needed
  * use the COLOR_<colo> macro values for pair numbers
* Updated the player_t struct to hold the now required fields
  * such as color, health, damage, etc...
* Created c-struct for objects, along with constructor
* Created print methods to print the given player or object symbol in required color
* Modified the generate_dungeon function to take monster and object description vectors
* created method to randomly generate required number of player_t
  * stored in dungeon struct

7 April - fix description bug

* misunderstood parsing of description... now will read in as is with new lines
* If description not closed, will parse till end of file. Will detect, user error

31 March - implement objects

* created object and object_type class
** looks like I'm done... using basically the same parser as last assignment
** need to double check, but looks like done

31 March - work on robustness

* worked to make robust
** skips over whitespace and new lines
** if any feature missing or done twice, will skip monster

29 March - Ported to C

* worked to have compile with existing C files
** needed to use void pointers and wrapper functions
** not sure if correct, but works with no memory leaks

26 March - Started C++ parser

* created classes to hold certain types of data
** dice param for holding dice roles
** color to hold certain types of color
** ability to hold certain types of abilities
* each class can only take certain inputs, else throws error
** errors can be used by parser to tell when invalid input
* created monster class
** uses the classes above
* Defined tags for parsing
* can do basic reading of specified text file

24 March - Fixed bugs (kinda) and implemented file handeling

* now will destroy save file if player looses/wins
* defaults to loading save file if exists, or generates new file with new dungeon
* fixed no_show bug, monsters would not appear until player moved one space
  * temporay fix, will be fixed better when code restructured
* Good to submit...

16 March - Implemented new Save functionality

* basic changes made in the car, rewrite the save_file functions
* realized that alot of code is spaghetti and that will need to rewrite/restructure sometime soon
  * not now...
* Works, have to now debug no_show bug when loading from save file
* need to remove file when player wins/looses
* need to load from save on default, or create if none existing

24 February - Fixed monsters

* when monsters meet, now can die
* PC only wins if last one standing
  * when monster dies, decrements num_monsters_alive

24 Febryary - Debugging

* Fixed priority queue
  * nasty bug, was storing... long story - it works now
* Added attribute to NPC - can know if seen PC or not
* fixed dumb_next - logic condition backwards
* fixed meander - only moves in x or y direction, not both
* added timer to main
* fixed logic in move_ocupant
  * checking in incorrect order
* added method, last_seen
  * for given monster, checks if can see PC
  * if so, stores location in monster struct
  * called before every move
* added check in move_ocupant, sees who "jumps" first
  * can see which character wins
  * also, if monster -> monster, no move
* added function, same_room
  * tells if two players are in teh same room

23 February - Added player_t type

   **Yes, I actually did do all of this today - very glitchy however**

* created new struct, player_t
  * always has index (PC always 0), symbol, speed, turn
  * internal union, so either PC or NPC
  * NPC has attributes, last_seen, name, description, etc..
* updated dungeon struct
  * now knows if space is ocupied
* created two new methods, PC/NPC gen
  * creates new PC/NPC with random attributes
* created new method, place_ocupant (will probably be removed)
  * places new ocupant on respective space
  * only to be called at gen time (kinda useless)
* created new method is_ocupied
  * returns the current ocupant to a square
  * NULL if no ocupied
* created method, dumb_next
  * will move character in X or Y (whichever direction furthest) closer to target
  * Checks for walls, if wall, no move
* renamess/edited method, next_move to smart_next
  * used dij to target
  * checks for walls, if wall, no move
* created method, meander
  * randomly moves in x/y direction
  * checks for walls, if wall, no move
* created method, move_ocupant
  * takes player_t, calls correct movement method
  * movement depends on player attributes (smart, tele)
  * PC always meanders for now
* Added Turn queue to main
  * stores pointers to player_t objects, housed in dungeon struct
  * when PC moved, print dungeon

17 February - Fixed random room picking

* Now makes sure that two rooms picked in debug_next_move() are not the same room
* Added additional argument to dij(), can either iterate through all possible paths, or stop when find end_square

16 February - Fixed next_move()

* next_move now does not seg fault on last (one closest to start)

9 February - Major dij restructure

* so, seperated out the carve_path function into many smaller functions
  * now have dij function that takes pre-allocated parrent array, fills in with breadcrumbs
  * have a seperate method that will print entire contens of parent array (for carving paths
  * have another method that will take parent array, work backwards, return next spot to be traversed to for shortest path (next_move())
* next_move() having problems, working until last move (going one too far)
  * Assignment extended, fix later
* implemented debug_next_move() to randomly choose two rooms, call dij repeatedly, plotting next moves one by one
	
8 February - Valgrind nightmare

* found that valgrind on different operating systems are different - yeah
  * Now running compile and valgrind only on pyrite
  * found and fixed MANY malloc/free gottcha's
  * priority queue now (damn near) perfect
* need to make bubble and tickle methods of p_q static (local/private)

4 February - New type of priority queue

* implemented a binary heap in place of linear priority queue
* tested, works with dij algo
  * need to run valgrind, fix error-leaks
	
2 February - Implemented tiles in dungeon grid

* to better differentiate between rooms and paths
  * new struct, one for each space
  * holds type and hardness
* created typedef
  * between room, path, wall, stone
* revised load/save for new tiles
* new functions, place_type and get_type
* rewrite place for writing random hardness
* tested on pyrite
  * caught potentially nasty malloc bug
* removed some arguments (for now)
  * fixed X and Y (160, 96)
  * fixed num rooms (12)
* modified dijkstra's, now only 4 directions instead of 8

1 February - Checked with provided save files

* modified write order of maze grid
  * needed to write by row, not coloumn 

28 January - Added load/save - Implemented Dijkstra's

* added --load & --save flags
  * modified structure of main, check for load flag, if so no generate
  * lastly before exit, check if need to save
  * made sure to free in all error cases
  * made sure to crash gracefully for misread file, no file
* created load and save functions
  * made sure to adhear to network endianess
  * made sure to fail gracefully to main
  * made sure to free when needed
  * tested, worked 
  * **Need to do something with load size**

* Finished implementing Dijkstra's
  * little slow, need to make more efficient
  * sometimes not quite the shortest? need to modify hardness of rock
  * weight differently

27 January - Added README file
   
26 January - Implemented Path generation
* repaired hausdorff understanding
* created function to find what rooms should be connected to which.
* created function to carve tunnels
  * finds random section of facing walls
  * finds direct path from start to end
  * carves out one by one, rechecking to make sure is on target
  * at this point in time, carves through other rooms
    * still ensures that rooms are connected 
    * still ensures that all rooms are connected to each other

25 January - Implemented Room generation
* Created Room struct
  * keeps track of four-corners, dimensions
* created function to generate rooms to an area
* created point_type struct
  * stores (x, y) pair
* created function to calculate hausdorf distance between rooms
* created function to calculate distance between points
* created function to calculate center of room
* created function to place rooms in dungeon
  * created function to see if room can be safely placed
  * checks if satisifies hausdorff distance

22 January - Start of project

* Created Dungeon struct
  * keeps track of number of rooms, rooms, representation, dimensions
* Created function to generate dungeon
  * generate outside boarders
  * fills insides with stones, 0 - 9
* Implemented command-line arguments
  * uses defaults, but can be overridden
* created function to destroy (free) dungeon.
